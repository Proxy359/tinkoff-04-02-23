/*Вам необходимо делегировать сотруднику нетривиальную задачу — покрасить забор, состоящий из m досок. Сотрудник не способен ничего делать без мотивации, поэтому вы придумали n мотивирующих цитат, имеющие эффективности p_1, p_2, . . . , p_np
1,p 2,...,p n. В любой момент времени вы можете подойти к сотруднику и произнести любую мотивирующую цитату, не произнесенную ранее.

Посмотрим на произвольный рабочий день. Если за день вы рассказали сотруднику цитаты с номерами i_1, i_2, ..., i_ki 1,i 2,...,i k
то он за этот день покрасит p_{i1} +max(0,p_{i2} −1)+...+max(p_{ik} −k+1) p
i1+max(0,p i2−1)+...+max(p ik−k+1)досок. Например, если в первый день рассказать цитаты с эффективностями 9, 4, 7, а во второй день — цитаты с эффективностями 8, 5, 1, то за первый день сотрудник покрасит 9+3+5 досок, а за второй — 8+4+0 досок.

Если в какой-то день сотрудника не мотивировать, он ничего не будет делать.
Задача очень важная, необходимо ее выполнить как можно скорее. Определите, сколько дней уйдет на покраску забора при оптимальной своевременной мотивации сотрудника или определите, что мотивирующие цитаты не позволят справиться с данной задачей.



Формат входных данных
Первая строка содержит числа n (3 \leqslant  n \leqslant   2·10^5)n(3⩽n⩽2⋅10
5) и m (1 \leqslant   m \leqslant  10^9)m(1⩽m⩽10 9) — количества мотивирующих цитат и досок соответственно.
Вторая строка содержит числа p_1, p_2, . . . , p_n (1 \leqslant  pi \leqslant  10^9)p 1,p 2,...,p n(1⩽pi⩽10 9) — эффективности мотивирующих цитат.

Формат выходных данных
Если справиться с покраской забора невозможно, выведите -1. В противном случае выведите минимальное количество дней, необходимых для выполнения этой задачи.*/

package main

import (
	"fmt"
	"sort"
)

func main() {
	var phrase, board int
	fmt.Scan(&phrase, &board)

	efficacy := []int{}
	counter := 0
	for i := 0; i < phrase; i++ {
		var cEfficacy int
		fmt.Scan(&cEfficacy)
		efficacy = append(efficacy, cEfficacy)
		counter += efficacy[i]
	}
	if counter < board {
		fmt.Println(-1)
		return
	}

	sort.SliceStable(efficacy, func(i, j int) bool {
		return efficacy[i] > efficacy[j]
	})

	sum := 0
	for i := 0; i < len(efficacy); i++ {
		if runThat(efficacy[i:], sum, board) == true {
			fmt.Println(i + 1)
			return
		}
		sum += efficacy[i]
	}

}

func runThat(efficacy []int, sum, board int) bool {
	cSum := 0
	for i := 0; i < len(efficacy); i++ {
		cSum += efficacy[i] - i
	}
	if (cSum + sum) >= board {
		return true
	}
	return false
}
